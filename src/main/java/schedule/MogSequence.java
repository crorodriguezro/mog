package schedule;

import model.Schedule;
import model.Solution;
import project.Activity;

import java.util.Comparator;
import java.util.List;
import java.util.Random;
import java.util.stream.Collectors;

public class MogSequence extends Sequence {

  /**
   * Esta clase realiza las acciones para obtener la secuencia "S" por el modelo MOG
   */
  void startNextActivities() {
    Random random = new Random();
    /* Random para escoger la regla de prioridad
        Determine randomly a priority rule;
    (0) Lower duration: a solution s is generated by sequencing
        activities in non-decreasing order of the value of its duration;
    (1) Bigger number of successors activities: a solution s is generated
        by sequencing activities in non-increasing order of its numbers
        of successors activities;
    (2) Lower weight: a solution s is generated by sequencing activities
        in non-decreasing order of the value of its weight.
     */
    int method = random.nextInt(3);
    List<Activity> doableActivities = getDoableActivities(availableActivities);
    // Si no hay trabajos que se puedan hacer nos salimos del metodo
    if (doableActivities.size() == 0) {
      return;
    }
    int[] resourcesNeeded = new int[resources.length];
    for (int i = 0; i < resourcesNeeded.length; i++) {
      int finalI = i;
      resourcesNeeded[finalI] = doableActivities.stream()
          .mapToInt(activity -> activity.getResources()[finalI]).sum();
    }

    if(areAvailableResources(resourcesNeeded)){
      doableActivities.forEach(this::startActivity);
      return;
    }

    // Ordenamos los trabajos segun el metodo
    List<Activity> sortedActivities = getSortedActivitiesByMethod(doableActivities, method);

    List<Activity> shrinkList;
    // "sorteActivities" es la lista de trabajos ya ordenada
    // "shrinkListMaxIndex" representa el numero de items que vamos a coger la cantidad de trabajos disponibles
    // Sacamos una sublista escogiendo los primeros "shrinkListMaxIndex" items deacuerdo al random de %
    int shrinkListSize = random.nextInt(sortedActivities.size());
    int shrinkListMaxIndex = shrinkListSize == 0 ? 1 : shrinkListSize;
    shrinkList = sortedActivities.subList(0, shrinkListMaxIndex);
    //Buscamos trabajos hasta que ya no queden mas recursos disponibles o mas trabajos
    int activityTodoIndex;
    while (shrinkList.size() > 0) {
      activityTodoIndex = random.nextInt(shrinkList.size());
      startActivity(shrinkList.get(activityTodoIndex));
      shrinkList.remove(shrinkList.get(activityTodoIndex));
      // Vamos a quitar de la lista "shrinkList" el trabajo iniciado
      doableActivities = getDoableActivities(shrinkList);

      // Si ya no hay trabajos que se puedan hacer entonnes nos salimos del ciclo
      if(doableActivities.size() == 0){
        break;
      }
      // "sorteActivities" es la lista de trabajos ya ordenada
      // "shrinkListMaxIndex" representa el numero de items que vamos a coger la cantidad de trabajos disponibles
      // Sacamos una sublista escogiendo los primeros "shrinkListMaxIndex" items deacuerdo al random de %
      method = random.nextInt(3);
      sortedActivities = getSortedActivitiesByMethod(doableActivities, method);
      shrinkListSize = random.nextInt(sortedActivities.size());
      shrinkListMaxIndex = shrinkListSize == 0 ? 1 : shrinkListSize;
      shrinkList = sortedActivities.subList(0, shrinkListMaxIndex);
    }
  }

  /**
   * Metodo para obtener los recursos disponibles
   * @param resources Recursos disponibles
   * @return Verdadero o falso
   */
  private boolean areAvailableResources(int[] resources) {
    for (int j = 0; j < resources.length; j++) {
      if (resources[j] > this.resources[j].getAmount()) {
        return false;
      }
    }
    return true;
  }

  public Solution getSolution(Schedule schedule) {
    return new Solution(generateSequence(schedule), -1, -1);
  }

  /**
   * Metodo para seleccionar las actividades deacuerdo al random
   * @param doableActivities Posibles actividades para iniciar
   * @param method Metodo para seleccionar la siguiente actividad
   * @return Actividad seleccionada
   */
  private List<Activity> getSortedActivitiesByMethod(List<Activity> doableActivities, int method) {
    Comparator<Activity> comparator;
    switch (method) {
      case 0: {
        comparator = Comparator.comparingInt(Activity::getDuration);
        break;
      }
      case 1: {
        comparator = Comparator.comparingInt(activity -> -activity.getSuccessors().size());
        break;
      }
      case 2: {
        comparator = Comparator.comparingInt(activity -> activity.getWeight());
        break;
      }
      default:
        throw new RuntimeException("Opci√≥n: " + method);
    }
    return doableActivities.stream()
        .sorted(comparator)
        .collect(Collectors.toList());
  }
}
