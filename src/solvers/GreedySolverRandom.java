package solvers;

import java.util.Comparator;
import java.util.List;
import java.util.Random;
import java.util.stream.Collectors;
import model.Job;
import sun.reflect.generics.reflectiveObjects.NotImplementedException;

public class GreedySolverRandom extends GreedySolver {

  void startNextJobs() {
    Random random = new Random();
    /* Random para escoger la regla de prioridad
        Determine randomly a priority rule;
    (0) Lower duration: a solution s is generated by sequencing
        activities in non-decreasing order of the value of its duration;
    (2) Bigger number of successors activities: a solution s is generated
        by sequencing activities in non-increasing order of its numbers
        of successors activities;
    (3) Lower weight: a solution s is generated by sequencing activities
        in non-decreasing order of the value of its weight.
     */
    int method = random.nextInt(3);
    List<Job> doableJobs = getDoableJobs(availableJobs);
    // Si no hay trabajos que se puedan hacer nos salimos del metodo
    if (doableJobs.size() == 0) {
      return;
    }
    // Ordenamos los trabajos segun el metodo
    List<Job> sortedJobs = getSortedJobsByMethod(doableJobs, method);

    List<Job> shrinkList;
    int high = sortedJobs.size() + 1;
    int low = 1;
    int maxRandom = Integer.max(1, high - low);
    int shrinkListMaxIndex = random.nextInt(maxRandom) + low;
    // "sorteJobs" es la lista de trabajos ya ordenada
    // "shrinkListMaxIndex" representa el numero de items que vamos a coger la cantidad de trabajos disponibles
    // Sacamos una sublista escogiendo los primeros "shrinkListMaxIndex" items deacuerdo al random de %
// Todo falta el random que selecciona un trabajo al azar de la lista shrinkList
    shrinkList = sortedJobs.subList(0, shrinkListMaxIndex);
    //Buscamos trabajos hasta que ya no queden mas recursos disponibles o mas trabajos
    while (shrinkList.size() > 0) {
      startJob(shrinkList.get(0));
      shrinkList.remove(shrinkList.get(0));
      // Vamos a quitar de la lista "shrinkList" el trabajo iniciado
// Todo se debe borrar la lista y volver a realizar el ciclo en el mismo p// eriodo de tiempo hasta que no
// Todo tengamos mas recursos o mas trabajos disponibles
      doableJobs = getDoableJobs(shrinkList);
      shrinkList = getSortedJobsByMethod(doableJobs, method);
    }
  }

  private List<Job> getSortedJobsByMethod(List<Job> doableJobs, int method) {
    Comparator<Job> comparator;
    switch (method) {

      case 0: {
        comparator = Comparator.comparingInt(Job::getDuration);
        break;
      }
      case 1: {
        comparator = Comparator.comparingInt(job -> -job.getSuccessors().size());
        break;
      }
      case 2: {
        comparator = Comparator.comparingInt(job -> job.getWeight());
        break;
      }
      default:
        throw new RuntimeException("Opci√≥n: " + method);
    }
    return doableJobs.stream()
        .sorted(comparator)
        .collect(Collectors.toList());
  }
}
