package solvers;

import java.util.Comparator;
import java.util.List;
import java.util.Random;
import java.util.stream.Collectors;
import model.Job;

public class GreedySolverRandom extends GreedySolver {

  void startNextJobs() {
    Random random = new Random();
    /* Random para escoger la regla de prioridad
        Determine randomly a priority rule;
    (0) Lower duration: a solution s is generated by sequencing
        activities in non-decreasing order of the value of its duration;
    (2) Bigger number of successors activities: a solution s is generated
        by sequencing activities in non-increasing order of its numbers
        of successors activities;
    (3) Lower weight: a solution s is generated by sequencing activities
        in non-decreasing order of the value of its weight.
     */
    int method = random.nextInt(3);
    List<Job> doableJobs = getDoableJobs(availableJobs);
    // Si no hay trabajos que se puedan hacer nos salimos del metodo
    if (doableJobs.size() == 0) {
      return;
    }
    // Ordenamos los trabajos segun el metodo
    List<Job> sortedJobs = getSortedJobsByMethod(doableJobs, method);

    List<Job> shrinkList;
    // "sorteJobs" es la lista de trabajos ya ordenada
    // "shrinkListMaxIndex" representa el numero de items que vamos a coger la cantidad de trabajos disponibles
    // Sacamos una sublista escogiendo los primeros "shrinkListMaxIndex" items deacuerdo al random de %
    int shrinkListSize = random.nextInt(sortedJobs.size());
    int shrinkListMaxIndex = shrinkListSize == 0 ? 1 : shrinkListSize;
    shrinkList = sortedJobs.subList(0, shrinkListMaxIndex);
    //Buscamos trabajos hasta que ya no queden mas recursos disponibles o mas trabajos
    int jobTodoIndex;
    while (shrinkList.size() > 0) {
      jobTodoIndex = random.nextInt(shrinkList.size());
      startJob(shrinkList.get(jobTodoIndex));
      shrinkList.remove(shrinkList.get(jobTodoIndex));
      // Vamos a quitar de la lista "shrinkList" el trabajo iniciado
      doableJobs = getDoableJobs(shrinkList);

      // Si ya no hay trabajos que se puedan haccer entoncnes no sasalimos del ciclo
      if(doableJobs.size() == 0){
        break;
      }
      // "sorteJobs" es la lista de trabajos ya ordenada
      // "shrinkListMaxIndex" representa el numero de items que vamos a coger la cantidad de trabajos disponibles
      // Sacamos una sublista escogiendo los primeros "shrinkListMaxIndex" items deacuerdo al random de %
      method = random.nextInt(3);
      sortedJobs = getSortedJobsByMethod(doableJobs, method);
      shrinkListSize = random.nextInt(sortedJobs.size());
      shrinkListMaxIndex = shrinkListSize == 0 ? 1 : shrinkListSize;
      shrinkList = sortedJobs.subList(0, shrinkListMaxIndex);
    }
  }

  private List<Job> getSortedJobsByMethod(List<Job> doableJobs, int method) {
    Comparator<Job> comparator;
    switch (method) {

      case 0: {
        comparator = Comparator.comparingInt(Job::getDuration);
        break;
      }
      case 1: {
        comparator = Comparator.comparingInt(job -> -job.getSuccessors().size());
        break;
      }
      case 2: {
        comparator = Comparator.comparingInt(job -> job.getWeight());
        break;
      }
      default:
        throw new RuntimeException("Opci√≥n: " + method);
    }
    return doableJobs.stream()
        .sorted(comparator)
        .collect(Collectors.toList());
  }
}
